---
layout: ../../layouts/BlogLayout.astro
title: Our Industry is Changing
description: Our Industry is Changing
date: 星期五 01 下午 一月 31o 2025
author: alexkondov
origin_url: https://mailchi.mp/2d979bd69f66/our-industry-is-changing?e=6955ce1080
origin_site: https://mailchi.mp/2d979bd69f66/our-industry-is-changing?e=6955ce1080
translated: true
avatar: /media-source/alexkondov-ico.png
email_recorder: alexkondov38@147790190.mailchimpapp.com
---

import { Detail } from '@/components/Detail.tsx';
import { Reference } from '@/components/Reference.tsx';

<Reference client:only="react" title="Our Industry is Changing" url="https://mailchi.mp/2d979bd69f66/our-industry-is-changing?e=6955ce1080" />

<Detail client:only="react">
	![](https://mcusercontent.com/fca75767fa83fa3473478b4ca/images/38ca00ab-a0f7-cb3d-ecc8-8766da856ac2.png)

_"This is a short newsletter-first article I just wrote about how I approach our craft in the age of LLMs. I felt that it's important to share it because the noise and hype around them on social media is unbearable. Our craft is changing but I'm betting on acquiring even more technical knowledge.  
  
I'll message you all again on February 12th when Full-Stack Tao officially releases!"_  
 

## Our Craft is Changing

In the last couple of years, AI went from something I disregarded as a fancy recommendation algorithm to a source of existential dread.

I saw programming work as that weird intersection of logic and creativity that could never possibly be automated. I honestly expected it to be the last craft we turn into an assembly line before we set off into the UBI sunset.

But I was wrong.

LLMs went from “yeah it can sometimes generate working code” to “yeah but it didn’t catch that one edge case” way quicker than I thought they would.

Turns out it’s all pattern-matching all the way down. Who would’ve thought?

I’ve invested the last 10 years of my life in this industry, hoping to bear the fruits of my efforts.

And I’d be only half-joking when I say that I’m wondering whether I should’ve picked a different outlet for my creative aspirations.

But I’m not skeptical about the software industry.

It’s just that the level of abstraction is increasing once again. It’s like the move from low-level languages to high-level ones, but this comes with a paradigm shift.

Most industry shifts so far have resulted in us still sitting at the keyboard, writing code.

This time we’ll be spending a lot more time reading code than writing it ourselves. We’ll be turning from writers to editors.

Our craft is changing.

It’s important to see yourself as a builder, not as a writer of code.

From the people who create the implementation, we’ll be the ones estimating its quality and correctness, recognizing the good, the bad, and the code that needs to change.

In this world, being able to differentiate between good maintainable code can make the difference in a software product’s future.

Because writing code to satisfy a requirement seems to be a solved problem. But you still need to:

*   Know what you need to build.
*   Know how it needs to behave.
*   Know how it needs to evolve.

I can prompt an LLM to write me code that reads files from an S3 bucket and sends HTTP requests to another service. But:

*   I need to know that these reads should happen concurrently.
*   I need to know that I should batch my subsequent requests so I don’t overload another service.
*   I need to know that I need an interface because I expect to have other file sources in the future and it would be easier to add them.

Maintaining software is hard.

And I can see a future in which everything is immutable and rewritten from scratch from a prompt every time a change needs to be made, but that’s still far off.

The people best equipped to work with these models are those with technical knowledge.

If you know what you need to build, AI is going to make you an even more productive creator.

That’s why I’m betting on acquiring even more technical knowledge about software design and distributed systems. The former so I can build an intuition about good code, and the latter so I can build more complex products.

  
  
  
  
  
  


</Detail>

![](https://mcusercontent.com/fca75767fa83fa3473478b4ca/images/38ca00ab-a0f7-cb3d-ecc8-8766da856ac2.png)

\_"This is a short newsletter-first article I just wrote about how I approach our craft in the age of LLMs. I felt that it's important to share it because the noise and hype around them on social media is unbearable. Our craft is changing but I'm betting on acquiring even more technical knowledge.

I'll message you all again on February 12th when Full-Stack Tao officially releases!"\_\
 

## Our Craft is Changing

In the last couple of years, AI went from something I disregarded as a fancy recommendation algorithm to a source of existential dread.

I saw programming work as that weird intersection of logic and creativity that could never possibly be automated. I honestly expected it to be the last craft we turn into an assembly line before we set off into the UBI sunset.

But I was wrong.

LLMs went from “yeah it can sometimes generate working code” to “yeah but it didn’t catch that one edge case” way quicker than I thought they would.

Turns out it’s all pattern-matching all the way down. Who would’ve thought?

I’ve invested the last 10 years of my life in this industry, hoping to bear the fruits of my efforts.

And I’d be only half-joking when I say that I’m wondering whether I should’ve picked a different outlet for my creative aspirations.

But I’m not skeptical about the software industry.

It’s just that the level of abstraction is increasing once again. It’s like the move from low-level languages to high-level ones, but this comes with a paradigm shift.

Most industry shifts so far have resulted in us still sitting at the keyboard, writing code.

This time we’ll be spending a lot more time reading code than writing it ourselves. We’ll be turning from writers to editors.

Our craft is changing.

It’s important to see yourself as a builder, not as a writer of code.

From the people who create the implementation, we’ll be the ones estimating its quality and correctness, recognizing the good, the bad, and the code that needs to change.

In this world, being able to differentiate between good maintainable code can make the difference in a software product’s future.

Because writing code to satisfy a requirement seems to be a solved problem. But you still need to:

* Know what you need to build.
* Know how it needs to behave.
* Know how it needs to evolve.

I can prompt an LLM to write me code that reads files from an S3 bucket and sends HTTP requests to another service. But:

* I need to know that these reads should happen concurrently.
* I need to know that I should batch my subsequent requests so I don’t overload another service.
* I need to know that I need an interface because I expect to have other file sources in the future and it would be easier to add them.

Maintaining software is hard.

And I can see a future in which everything is immutable and rewritten from scratch from a prompt every time a change needs to be made, but that’s still far off.

The people best equipped to work with these models are those with technical knowledge.

If you know what you need to build, AI is going to make you an even more productive creator.

That’s why I’m betting on acquiring even more technical knowledge about software design and distributed systems. The former so I can build an intuition about good code, and the latter so I can build more complex products.


